name: Supply Chain Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  packages: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: rock-paper-scissors
  TRIVY_DISABLE_VEX_NOTICE: "true"

jobs:
  prep_and_scan:
    name: Prep & Scan
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show workspace layout
        run: |
          pwd
          ls -la

      - name: Setup Task runner
        uses: arduino/setup-task@v1

      - name: Prepare Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Install Trivy scanner
        run: |
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy

      - name: Ensure Trivy ignore file exists
        run: |
          if [ ! -f .trivyignore ]; then
            echo "WARN: .trivyignore missing in checkout; creating empty file"
            : > .trivyignore
          fi
          ls -la .trivyignore

      - name: Run baseline scans (Trivy fs/iac)
        run: |
          mkdir -p attestations
          # Scan repo root so dependency files (e.g. requirements.txt) are included
          # Skip local virtualenvs, otherwise Trivy reports CVEs from dev env packages
          trivy fs --ignorefile ./.trivyignore \
            --skip-dirs .git \
            --skip-dirs attestations \
            --skip-dirs venv \
            --skip-dirs .venv \
            --format cosign-vuln . > attestations/vuln-source.json
          if [ -d src/docker ]; then
            trivy config --format cosign-vuln src/docker/ > attestations/vuln-dockerfile.json || true
          else
            echo '{}' > attestations/vuln-dockerfile.json
            echo "skip: src/docker not found"
          fi
          if [ -d src/iac ]; then
            trivy config --format cosign-vuln src/iac/ > attestations/vuln-iac.json || true
          else
            echo '{}' > attestations/vuln-iac.json
            echo "skip: src/iac not found"
          fi

      - name: Build app image (for vuln scan)
        run: docker build --no-cache -t rock-paper-scissors:latest -f src/docker/Dockerfile .

      - name: Show Python package versions in image
        run: |
          docker run --rm rock-paper-scissors:latest python -m pip show wheel jaraco.context || true

      - name: Scan image and enforce HIGH/CRITICAL policy
        run: |
          trivy image --ignorefile ./.trivyignore --severity HIGH,CRITICAL --exit-code 1 rock-paper-scissors:latest
          trivy image --ignorefile ./.trivyignore --format cosign-vuln rock-paper-scissors:latest > attestations/vuln-image.json

      - name: Upload attestation bundle
        uses: actions/upload-artifact@v4
        with:
          name: attestations
          path: attestations/

  build_and_push:
    name: Build & Push
    runs-on: ubuntu-latest
    needs: prep_and_scan
    outputs:
      image: ${{ steps.meta.outputs.image }}
      digest: ${{ steps.push.outputs.digest }}
      image_ref: ${{ steps.meta.outputs.image }}@${{ steps.push.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute image ref
        id: meta
        run: |
          OWNER_LOWER="${{ github.repository_owner }}"
          IMAGE="ghcr.io/${OWNER_LOWER,,}/${{ env.IMAGE_NAME }}"
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"

      - name: Docker Buildx (push with provenance + SBOM)
        id: push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./src/docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.image }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: mode=max
          sbom: true

  sign_and_verify:
    name: Sign & Verify
    runs-on: ubuntu-latest
    needs: build_and_push
    env:
      IMAGE_REF: ${{ needs.build_and_push.outputs.image_ref }}
      IMAGE_DIGEST: ${{ needs.build_and_push.outputs.digest }}
      IMAGE_NAME_NO_TAG: ${{ needs.build_and_push.outputs.image }}
    steps:
      - name: Login to GHCR (for cosign)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download attestation bundle
        uses: actions/download-artifact@v4
        with:
          name: attestations
          path: attestations

      - name: Install Cosign
        uses: sigstore/cosign-installer@v2
        with:
          cosign-release: 'v2.4.0'

      - name: Generate SLSA provenance predicate (local)
        run: |
          mkdir -p attestations
          cat > attestations/provenance.slsa.json <<'JSON'
          {
            "builder": {
              "id": "https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
            },
            "buildType": "https://github.com/Attestations/GitHubActions@v1",
            "invocation": {
              "configSource": {
                "uri": "git+https://github.com/${GITHUB_REPOSITORY}@${GITHUB_SHA}",
                "digest": {"sha1": "${GITHUB_SHA}"}
              },
              "parameters": {
                "workflow": "${GITHUB_WORKFLOW}",
                "ref": "${GITHUB_REF}",
                "runner": "${RUNNER_OS}"
              }
            },
            "metadata": {
              "buildInvocationId": "https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}",
              "buildStartedOn": "${GITHUB_RUN_ATTEMPT}",
              "buildFinishedOn": "${GITHUB_RUN_ATTEMPT}"
            },
            "materials": [
              {
                "uri": "git+https://github.com/${GITHUB_REPOSITORY}@${GITHUB_SHA}",
                "digest": {"sha1": "${GITHUB_SHA}"}
              }
            ]
          }
          JSON

      - name: Generate SBOM (SPDX JSON)
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.IMAGE_REF }}
          format: spdx-json
          output-file: attestations/sbom.spdx.json

      - name: Attach attestations (provenance, SBOM, vulnerabilities)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          # NOTE: GitHub's `actions/attest-*` are not available for user-owned private repos.
          # We attach provenance + SBOM as cosign attestations directly to the OCI registry instead.
          for TYPE in provenance sbom vuln-source vuln-dockerfile vuln-iac vuln-image; do
            case $TYPE in
              provenance) PRED=attestations/provenance.slsa.json; T=https://slsa.dev/provenance/v1 ;;
              sbom) PRED=attestations/sbom.spdx.json; T=https://spdx.dev/Document ;;
              vuln-source) PRED=attestations/vuln-source.json; T=https://cosign.dev/attestation/vuln/source ;;
              vuln-dockerfile) PRED=attestations/vuln-dockerfile.json; T=https://cosign.dev/attestation/vuln/dockerfile ;;
              vuln-iac) PRED=attestations/vuln-iac.json; T=https://cosign.dev/attestation/vuln/iac ;;
              vuln-image) PRED=attestations/vuln-image.json; T=https://cosign.dev/attestation/vuln/image ;;
            esac
            cosign attest --yes --type "$T" --predicate "$PRED" "${IMAGE_REF}"
          done

      - name: Sign container (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          echo "Signing ${IMAGE_REF}"
          cosign sign --yes "${IMAGE_REF}"

      - name: Verify signature
        run: |
          cosign verify --experimental-oci11 \
            --certificate-identity-regexp="https://github.com/.+" \
            --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com" \
            "${IMAGE_REF}"

      - name: Verify attestations (cosign)
        run: |
          for TYPE in \
            "https://slsa.dev/provenance/v1" \
            "https://spdx.dev/Document" \
            "https://cosign.dev/attestation/vuln/source" \
            "https://cosign.dev/attestation/vuln/dockerfile" \
            "https://cosign.dev/attestation/vuln/iac" \
            "https://cosign.dev/attestation/vuln/image"; do
            cosign verify-attestation --experimental-oci11 \
              --type "$TYPE" \
              --certificate-identity-regexp="https://github.com/.+" \
              --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com" \
              "${IMAGE_REF}" > /dev/null
          done
          echo "âœ… All attestations verified."

      - name: Check Rekor for expected entries
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          HASH="${IMAGE_DIGEST#sha256:}"
          echo "ðŸ” Searching Rekor for $HASH"
          # The ghcr.io/sigstore/rekor-cli:latest container may not exist; use the official CLI binary.
          # Use the `releases/latest` redirect to avoid GitHub API auth/rate-limit issues.
          curl -sSfL \
            "https://github.com/sigstore/rekor/releases/latest/download/rekor-cli-linux-amd64" \
            -o rekor-cli
          sudo install -m 0755 rekor-cli /usr/local/bin/rekor-cli
          rekor-cli version
          rekor-cli search --sha "$HASH" --format json > rekor-output.json
          cat rekor-output.json | jq
          ENTRY_COUNT=$(jq -r '.UUIDs | length' rekor-output.json)
          if [ "$ENTRY_COUNT" -lt 6 ]; then
            echo "âŒ Rekor entry count less than 6)" && exit 1
          fi
          echo "âœ… Rekor has at least 6 entries."

      - name: Upload Rekor output
        uses: actions/upload-artifact@v4
        with:
          name: rekor-output
          path: rekor-output.json

  consume_from_pipeline:
    name: Download, Verify & Run (From CI)
    runs-on: ubuntu-latest
    needs:
      - build_and_push
      - sign_and_verify
    env:
      IMAGE_REF: ${{ needs.build_and_push.outputs.image_ref }}
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v2
        with:
          cosign-release: 'v2.4.0'

      - name: Pull image produced by CI/CD
        run: |
          echo "Pulling ${IMAGE_REF}"
          docker pull "${IMAGE_REF}"

      - name: Verify signature before execution
        run: |
          cosign verify --experimental-oci11 \
            --certificate-identity-regexp="https://github.com/.+" \
            --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com" \
            "${IMAGE_REF}"

      - name: Run container (non-interactive smoke test)
        run: |
          # Run the CI-produced container only after signature verification.
          # Use a non-interactive entrypoint so CI does not hang waiting for user input.
          docker run --rm --entrypoint python "${IMAGE_REF}" -c "import main; print('Smoke test OK')"

  build_binary:
    name: Build & Sign Binary
    runs-on: ubuntu-latest
    needs: prep_and_scan
    outputs:
      binary_hash: ${{ steps.hash.outputs.hash }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build binary in Ubuntu 22.04 container (glibc 2.35 compatibility)
        run: |
          docker run --rm -v "$PWD:/app" -w /app ubuntu:22.04 bash -c "
            export DEBIAN_FRONTEND=noninteractive
            apt-get update && apt-get install -y python3 python3-pip python3-venv binutils
            python3 -m venv /tmp/venv
            . /tmp/venv/bin/activate
            pip install --upgrade pip
            pip install -r requirements.txt pyinstaller
            cd src/app
            # Include all local modules as hidden imports
            pyinstaller --onefile --name rps-game \
              --add-data '../../requirements.txt:.' \
              --hidden-import=http_api \
              --hidden-import=protocol \
              --hidden-import=game \
              --hidden-import=commit_reveal \
              --hidden-import=rps_client \
              --hidden-import=scoreboard \
              --hidden-import=spiffe_mtls \
              --hidden-import=move_signing \
              --hidden-import=main \
              cli.py
            chmod +x dist/rps-game
            ls -lh dist/
          "
          # Fix ownership - Docker runs as root, but runner needs write access
          sudo chown -R $(id -u):$(id -g) src/app/dist/

      - name: Test binary
        run: |
          cd src/app
          ./dist/rps-game --help || echo "Binary needs interactive mode"

      - name: Compute hash for signing
        id: hash
        run: |
          HASH=$(sha256sum src/app/dist/rps-game | awk '{print $1}')
          echo "hash=$HASH" >> "$GITHUB_OUTPUT"
          echo "Binary SHA256: $HASH"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v2
        with:
          cosign-release: 'v2.4.0'

      - name: Sign binary with Cosign (blob mode)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cd src/app/dist
          cosign sign-blob --yes \
            --bundle rps-game.cosign.bundle \
            rps-game
          echo "âœ… Binary signed, bundle: rps-game.cosign.bundle"

      - name: Stage binary for upload
        run: |
          mkdir -p ./release-staging
          cp src/app/dist/rps-game ./release-staging/
          cp src/app/dist/rps-game.cosign.bundle ./release-staging/
          ls -la ./release-staging/

      - name: Upload binary + signature as artifact
        uses: actions/upload-artifact@v4
        with:
          name: rps-game-binary
          path: ./release-staging/

  verify_and_run_binary:
    name: Verify & Run Binary
    runs-on: ubuntu-latest
    needs: build_binary
    steps:
      - name: Download binary artifact
        uses: actions/download-artifact@v4
        with:
          name: rps-game-binary
          path: ./binary

      - name: List downloaded files
        run: |
          echo "Contents of ./binary:"
          ls -laR ./binary/

      - name: Install Cosign
        uses: sigstore/cosign-installer@v2
        with:
          cosign-release: 'v2.4.0'

      - name: Verify binary signature before execution
        run: |
          cd binary
          cosign verify-blob \
            --bundle rps-game.cosign.bundle \
            --certificate-identity-regexp="https://github.com/.+" \
            --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com" \
            rps-game
          echo "âœ… Binary signature verified!"

      - name: Make binary executable
        run: chmod +x binary/rps-game

      - name: Run verified binary (help command)
        run: |
          ./binary/rps-game --help || echo "Binary executed successfully"

  publish_release:
    name: Publish Release
    runs-on: ubuntu-latest
    needs:
      - build_binary
      - verify_and_run_binary
    permissions:
      contents: write
    steps:
      - name: Download binary artifact
        uses: actions/download-artifact@v4
        with:
          name: rps-game-binary
          path: ./release

      - name: List downloaded files
        run: |
          echo "Contents of ./release:"
          ls -laR ./release/

      - name: Create release tag
        id: tag
        run: |
          TAG="v0.1.0-${{ github.run_number }}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release with binary
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: "Rock-Paper-Scissors ${{ steps.tag.outputs.tag }}"
          body: |
            ## Signed Binary Release

            This release contains the signed `rps-game` binary.

            ### Verification
            Download both files and verify the signature before running:
            ```bash
            cosign verify-blob \
              --bundle rps-game.cosign.bundle \
              --certificate-identity-regexp="https://github.com/.+" \
              --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com" \
              rps-game
            ```

            ### Usage
            ```bash
            chmod +x rps-game
            ./rps-game --help
            ```
          files: |
            release/rps-game
            release/rps-game.cosign.bundle
          draft: false
          prerelease: false
